<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magical AI Christmas Tree</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Times+New+Roman&display=swap" rel="stylesheet">

    <style>
        :root {
            --gold: #d4af37;
            --cream: #fceea7;
            --glass: rgba(20, 20, 20, 0.6);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Times New Roman', serif;
            color: var(--cream);
            user-select: none;
        }

        /* --- UI Overlay --- */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 10;
        }

        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: clamp(32px, 5vw, 56px);
            text-align: center;
            margin-top: 20px;
            font-weight: 700;
            background: linear-gradient(to bottom, #ffffff, var(--gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.6));
            letter-spacing: 2px;
            pointer-events: auto;
        }

        /* --- Controls --- */
        .controls-wrapper {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .upload-btn {
            background: var(--glass);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px 30px;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .upload-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }

        .hint-text {
            font-size: 12px;
            opacity: 0.7;
            color: #fff;
            margin-top: 5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        /* --- Loader --- */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.8s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-top: 3px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            letter-spacing: 3px;
            font-size: 14px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* --- Webcam (Hidden) --- */
        #webcam-container {
            position: fixed;
            bottom: 0;
            right: 0;
            opacity: 0; 
            pointer-events: none;
            display: flex;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">LOADING HOLIDAY MAGIC</div>
    </div>

    <div id="ui-container">
        <h1>Merry Christmas</h1>
        
        <div class="controls-wrapper">
            <button class="upload-btn" onclick="document.getElementById('file-input').click()">Add Memories</button>
            <input type="file" id="file-input" accept="image/*" style="display: none;">
            <div class="hint-text">Press 'H' to Hide Controls</div>
            <div class="hint-text" id="gesture-hint">Waiting for camera...</div>
        </div>
    </div>

    <div id="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas" width="160" height="120"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                gold: 0xd4af37,
                cream: 0xfceea7,
                red: 0xaa0000,
                green: 0x003311,
                orange: 0xffaa00,
                blue: 0x0044ff
            },
            particleCount: {
                mobile: { main: 600, dust: 1000 },
                desktop: { main: 1500, dust: 2500 }
            },
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        };

        // --- Global State ---
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            rotationTarget: { x: 0, y: 0 },
            targetPhoto: null,
            time: 0
        };

        const MODES = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };

        // --- Scene Globals ---
        let camera, scene, renderer, composer;
        let mainGroup, dustGroup;
        let particles = [];
        let handLandmarker;
        let video;
        let lastVideoTime = -1;
        let visionRunning = false;
        
        // Reusable Geometries & Materials (Optimization)
        const geoms = {};
        const mats = {};

        // --- Initialization ---
        async function init() {
            // 1. Setup Three.js
            const container = document.createElement('div');
            document.body.appendChild(container);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(CONFIG.isMobile ? 1 : window.devicePixelRatio); // Optimize pixel ratio
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.2;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 50);

            // 2. Environment & Lighting
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(CONFIG.colors.orange, 2, 50);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);

            const spotGold = new THREE.SpotLight(CONFIG.colors.gold, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.angle = 0.5;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);

            const spotBlue = new THREE.SpotLight(CONFIG.colors.blue, 600);
            spotBlue.position.set(-30, 20, -30);
            spotBlue.angle = 0.5;
            scene.add(spotBlue);

            // 3. Post Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7;
            bloomPass.strength = 0.45;
            bloomPass.radius = 0.4;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 4. Content Generation
            mainGroup = new THREE.Group();
            dustGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(dustGroup);

            initResources();
            createParticles();
            createDust();
            createDefaultPhoto();

            // 5. Input Handling
            setupInputs();

            // 6. Start Loop
            window.addEventListener('resize', onWindowResize);
            
            // 7. Load AI
            await setupMediaPipe();

            // Hide Loader
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 800);

            animate();
        }

        function initResources() {
            // Materials
            mats.gold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1 
            });
            mats.green = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, metalness: 0.3, roughness: 0.8 
            });
            mats.red = new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.colors.red, metalness: 0.1, roughness: 0.2, clearcoat: 1.0, clearcoatRoughness: 0.1 
            });
            
            // Geometries
            geoms.box = new THREE.BoxGeometry(1, 1, 1);
            geoms.sphere = new THREE.SphereGeometry(0.6, 16, 16);
            
            // Candy Cane Texture & Geom
            const caneCanvas = document.createElement('canvas');
            caneCanvas.width = 64; caneCanvas.height = 64;
            const ctx = caneCanvas.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#d00'; ctx.lineWidth = 20; ctx.beginPath();
            ctx.moveTo(-10, 10); ctx.lineTo(74, 94); ctx.stroke(); // Diagonal
            ctx.moveTo(30, -10); ctx.lineTo(114, 74); ctx.stroke();
            const caneTex = new THREE.CanvasTexture(caneCanvas);
            caneTex.wrapS = caneTex.wrapT = THREE.RepeatWrapping;
            mats.cane = new THREE.MeshStandardMaterial({ map: caneTex, roughness: 0.3 });

            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 2, 0),
                new THREE.Vector3(0.5, 2.5, 0),
                new THREE.Vector3(1, 2, 0)
            ]);
            geoms.cane = new THREE.TubeGeometry(path, 20, 0.2, 8, false);
        }

        function createParticles() {
            const count = CONFIG.isMobile ? CONFIG.particleCount.mobile.main : CONFIG.particleCount.desktop.main;
            const yMin = -10, yMax = 10;
            const height = yMax - yMin;

            for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = t * 50 * Math.PI;
                const maxRadius = 12;
                const radius = maxRadius * (1 - t);
                
                // Tree Coordinates
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = yMin + t * height;

                // Random Type
                const rand = Math.random();
                let mesh;
                let type = 'ORNAMENT';

                if (rand > 0.95) {
                    mesh = new THREE.Mesh(geoms.cane, mats.cane);
                    type = 'CANDY';
                } else if (rand > 0.7) {
                    mesh = new THREE.Mesh(geoms.sphere, rand > 0.85 ? mats.gold : mats.red);
                } else {
                    mesh = new THREE.Mesh(geoms.box, rand > 0.5 ? mats.gold : mats.green);
                    mesh.scale.setScalar(0.5);
                }

                // Initial Transform
                mesh.position.set(x, y, z);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                mainGroup.add(mesh);

                particles.push({
                    mesh: mesh,
                    type: type,
                    treePos: new THREE.Vector3(x, y, z),
                    scatterPos: new THREE.Vector3(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 20
                    ),
                    scatterVel: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.02),
                    baseScale: mesh.scale.clone(),
                    isPhoto: false
                });
            }
        }

        function createDust() {
            const count = CONFIG.isMobile ? CONFIG.particleCount.mobile.dust : CONFIG.particleCount.desktop.dust;
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) {
                pos.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: CONFIG.colors.gold, size: 0.15, transparent: true, opacity: 0.6 });
            const points = new THREE.Points(geom, mat);
            dustGroup.add(points);
        }

        // --- Photo Logic ---
        function createDefaultPhoto() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Draw default texture
            const gradient = ctx.createLinearGradient(0,0,512,512);
            gradient.addColorStop(0, '#880000');
            gradient.addColorStop(1, '#330000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0,512,512);
            ctx.font = 'bold 60px Cinzel';
            ctx.fillStyle = '#d4af37';
            ctx.textAlign = 'center';
            ctx.fillText("JOYEUX", 256, 230);
            ctx.fillText("NOEL", 256, 300);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(tex);
        }

        function addPhotoToScene(texture) {
            // Frame
            const frameGeo = new THREE.BoxGeometry(3.2, 3.2, 0.1);
            const frame = new THREE.Mesh(frameGeo, mats.gold);
            
            // Photo
            const photoGeo = new THREE.PlaneGeometry(3, 3);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.06;
            frame.add(photo);

            // Position in Tree
            const t = 0.6; // High up
            const angle = t * 50 * Math.PI;
            const r = 12 * (1 - t);
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = -10 + t * 20;

            frame.position.set(x, y, z);
            frame.lookAt(0, y, 0);
            
            mainGroup.add(frame);

            particles.push({
                mesh: frame,
                type: 'PHOTO',
                treePos: new THREE.Vector3(x, y, z),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, 20),
                scatterVel: new THREE.Vector3(0,0,0),
                baseScale: new THREE.Vector3(1,1,1),
                isPhoto: true
            });
        }

        function setupInputs() {
            // Keyboard H
            window.addEventListener('keydown', (e) => {
                if (e.key === 'h' || e.key === 'H') {
                    document.getElementById('ui-container').classList.toggle('ui-hidden');
                }
            });

            // File Upload
            const input = document.getElementById('file-input');
            input.addEventListener('change', (e) => {
                const f = e.target.files[0];
                if (!f) return;
                
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (t) => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToScene(t);
                    });
                };
                reader.readAsDataURL(f);
            });
        }

        // --- Computer Vision (MediaPipe) ---
        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            video = document.getElementById("webcam");
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 320, height: 240 } 
                });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    visionRunning = true;
                    predictWebcam();
                    document.getElementById('gesture-hint').innerText = "Camera Active: Show Hand!";
                });
            }
        }

        async function predictWebcam() {
            if (lastVideoTime !== video.currentTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks && results.landmarks.length > 0) {
                    processGestures(results.landmarks[0]);
                }
            }
            if (visionRunning) requestAnimationFrame(predictWebcam);
        }

        function processGestures(landmarks) {
            // Keypoints: 0(Wrist), 4(ThumbTip), 8(IndexTip), 12, 16, 20(Other Tips)
            const thumb = landmarks[4];
            const index = landmarks[8];
            const wrist = landmarks[0];
            
            // 1. Interaction: Map hand position to rotation
            const centerX = landmarks[9].x; // Middle finger base
            const centerY = landmarks[9].y;
            
            // Map 0..1 to -PI..PI
            STATE.rotationTarget.y = (centerX - 0.5) * 3; 
            STATE.rotationTarget.x = (centerY - 0.5) * 1;

            // 2. Gesture Recognition
            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            
            // Calculate average distance of fingertips to wrist
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            tips.forEach(i => {
                avgDist += Math.hypot(landmarks[i].x - wrist.x, landmarks[i].y - wrist.y);
            });
            avgDist /= tips.length;

            const hint = document.getElementById('gesture-hint');

            if (pinchDist < 0.05) {
                STATE.mode = MODES.FOCUS;
                hint.innerText = "Mode: FOCUS (Pinch Detected)";
            } else if (avgDist < 0.25) { // Fist
                STATE.mode = MODES.TREE;
                hint.innerText = "Mode: TREE (Fist Detected)";
            } else if (avgDist > 0.4) { // Open Hand
                STATE.mode = MODES.SCATTER;
                hint.innerText = "Mode: SCATTER (Open Hand Detected)";
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            STATE.time += 0.01;

            // 1. Global Rotation Smoothed
            mainGroup.rotation.y += (STATE.rotationTarget.y - mainGroup.rotation.y) * 0.05;
            mainGroup.rotation.x += (STATE.rotationTarget.x - mainGroup.rotation.x) * 0.05;

            // 2. Dust Animation
            dustGroup.rotation.y = STATE.time * 0.05;

            // 3. Logic based on Mode
            const targetVec = new THREE.Vector3();
            const photoFocusPos = new THREE.Vector3(0, 2, 35);

            // Determine active photo for focus mode
            if (STATE.mode === MODES.FOCUS && !STATE.targetPhoto) {
                // Find a random photo if none selected
                const photos = particles.filter(p => p.isPhoto);
                if (photos.length > 0) STATE.targetPhoto = photos[Math.floor(Math.random() * photos.length)];
            } else if (STATE.mode !== MODES.FOCUS) {
                STATE.targetPhoto = null;
            }

            particles.forEach(p => {
                let targetPos, targetScale;
                const speed = 0.05; // Lerp speed

                // Calculate Target
                if (STATE.mode === MODES.TREE) {
                    targetPos = p.treePos;
                    targetScale = p.baseScale;
                    // Gentle float in tree mode
                    p.mesh.rotation.y += 0.01;
                } 
                else if (STATE.mode === MODES.SCATTER) {
                    // Orbit logic
                    const r = 15;
                    p.scatterPos.applyAxisAngle(new THREE.Vector3(0,1,0), 0.002); // Slow orbit
                    targetPos = p.scatterPos;
                    targetScale = p.baseScale;
                    
                    // Self rotation
                    p.mesh.rotation.x += p.scatterVel.x * 10;
                    p.mesh.rotation.y += p.scatterVel.y * 10;
                } 
                else if (STATE.mode === MODES.FOCUS) {
                    if (p === STATE.targetPhoto) {
                        targetPos = photoFocusPos;
                        targetScale = new THREE.Vector3(4.5, 4.5, 4.5);
                        p.mesh.lookAt(camera.position); // Always face cam in focus
                    } else {
                        // Push others back
                        targetPos = p.scatterPos.clone().normalize().multiplyScalar(40); // Push far out
                        targetScale = p.baseScale;
                    }
                }

                // Apply Lerp
                p.mesh.position.lerp(targetPos, speed);
                if (p !== STATE.targetPhoto || STATE.mode !== MODES.FOCUS) {
                    p.mesh.scale.lerp(targetScale, speed);
                } else {
                    p.mesh.scale.lerp(targetScale, speed * 0.5); // Slower zoom for drama
                }
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>
